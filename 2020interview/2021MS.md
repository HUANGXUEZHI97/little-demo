## 第一部分Html

## 第二部分CSS


## 第三部分JS

1.数据类型

基本类型：number string boolean null undefined symbol
引用类型：object function array

2.类型判断：typeOf，instanceof，===的区别
typeOf：判断对象的基本类型，返回的是一个字符串，可以判断： number string boolean undefined，不可以判断：null和object  obiect和array
instanceof：判断一个对象是否是某个对象的实例，返回布尔值
===：可以判断 undefined  null

3.什么是实例对象什么是类型对象
实例：实例对象
类型：类型对象
function Person(name,age){  // 构造函数 类型对象
　　this.name=name
　　this.age=age
}
var p = new Person('Tom',12)  //根据构造函数而创建的为实例对象

此衍生出普通函数和构造函数的区别：
-  构造函数
  1. 用this来构造方法和属性；
  2. 用 new 关键字调用方法，生成实例对象；
  3. 命名开头大写；
  4. 检查一个对象是否是该构造函数的实例 —— instanceof


4.undefined和null的区别?什么时候给变量赋值为null？
undefined:定义未赋值
null:定义赋值了但是值为null
null：
（1） 作为函数的参数，表示该函数的参数不是对象。
（2） 作为对象原型链的终点。

undefined：
（1）变量被声明了，但没有赋值时，就等于undefined。
（2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。
（3）对象没有赋值的属性，该属性的值为undefined。
（4）函数没有返回值时，默认返回undefined。

5.严格区别数据类型和变量类型
1.数据类型：基本类型 对象类型
2.变量的类型（变量内存值的类型）
基本类型：保存的就是基本类型的数据
引用类型：保存的是地址值

6.数据，内存，变量
- 什么是数据？
数据就是存储在内存中的特定信息
内存中所有的操作目标就是数据
- 什么是内存？
就是一个存储数据的空间
一小块内存两个数据：1.地址值 2.内部存储的数据
内存分类： 1.栈：全局变量、局部变量 2.堆：对象
- 什么是变量？
可变化的量，变量名和值组成
每个变量都对应一小块内存，变量名用来查找对应的内存，变量值就是内存中保存的数据
- 关系
内存是用来存储数据的空间
变量是内存的标识

7.引用变量赋值
1.两个引用变量指向同一个对象，通过一个变量修改内部数据，另一个变量得到的是修改之后的数据。
2.两个引用变量指向同一个对象，让期中一个引用变量指向另一个对象，另一个引用变量依然指向前一个对象

8.JS引擎如何管理内存
- 内存的生命周期
分配较小的内存空间得到使用权
存储数据，反复进行操作
释放小内存空间
- 释放内存
局部变量：函数执行完自动释放
对象：变成垃圾对象，又垃圾回收器回收

垃圾回收机制：
无论任何编程语言，内存使用都是一样的：分配->使用->释放
javascript是自动给变量、函数分配内存的，当其为不可达（即可访问、可用的值）时，引擎会自动回收内存

问：JS在调用函数传递参数时，是值传递还是引用传递
//函数传参的问题：到底是值传递还是引用传递？
// 答：都是值传递，如果是基础类型就直接传值，如果是引用类型就传内存地址（如果是传递引用对象，这才叫引用传递）；

    var obj1 = {a:1}
    var obj2 = {a:2}
    
    function change(obj){
      obj.a = 3;
      obj = new Object();
      obj.a = 4;
      return obj;
    }
    
    obj3 = change(obj1)
    console.log('[ obj1 ]', obj1)
    console.log('[ obj2 ]', obj2)
    console.log('[ obj3 ]', obj3)
    
    // 如果obj1为{a:4的话，表明change的形参obj = 实参obj1，这叫引用传递，
    // 如果obj1为{a:3的话，表明change的形参obj 复制了 实参obj1，这叫值传递，传递的是obj1的内存地址；
    // 还是不懂看我的红宝书《javascript高级程序设计》P69-P71


9.什么是对象？
是一种类型，即引用类型。对象的值就是引用类型的实例。

10.为什么要用对象？
统一管理多个数据

11.对象的组成？
1.属性：属性名（字符串）和属性值（任意类型）组成
2.方法：一种特别的属性（属性值是函数）

12.对象的组成？什么时候必须要用['属性名']的方式?
1.通过属性名访问(编码简单，有时候不能用)
2.['属性名'](编码麻烦，都可以通用)
问题：什么时候必须要用['属性名']的方式？
1.属性名包含特殊字符: - 空格
2.属性名不确定

13.为什么要用函数?
1.提高代码复用
2.便于阅读交流

14.如何定义函数?
1.函数声明
2.表达式

15.如何调用(执行)函数?
1.test() // 直接调用
2.obg.test() // 通过对象调用
3.new test() // new调用
4.test.call / apply(obj) // 临时让test成为obj方法进行调用

ps:JS可以让一个函数成为指定任意对象的方法进行调用
var obj = {}
function test2(){
this.xxx='cailaoshi'
}
test2.call(obj)
console.log(obj.xxx) // cailaoshi

16.什么函数才是回调函数?常见的回调函数?
将函数当成参数传入另一个函数，当这个函数执行完后再去执行传入的函数，这个过程叫做回调，这个传入的函数叫做回调函数

常见回调函数：
1.dom事件回调函数
2.定时器回调函数
3.ajax回调函数
4.生命周期回调函数

17.匿名函数自调用的作用?
1.影藏实现
2,不会污染外部（全局）命名空间+
3.用它编写JS模

案例1：
(function(){ // 匿名函数自调用
var a= 3
console.log(a+3)
})() // 这里记得要加括号才能自执行
var a  =  4
console.log(a)

案例2：
(function(){
var a=1
function test(){
console.log(++a)
}
window.$ = function(){ // 向外暴露一个全局函数
     return{
          test:test
          }
     }
})
$().test() // 
1.$是一个函数
2.$执行后面返回的是一个对象
18.什么是原型?
函数prototype属性和实例对象的__proto__属性指向着原型对象
把所有的对象共用的属性全部放在堆内存的一个对象中（共用属性组成的对象），然后让每一个对象的 __proto__存储这个（共用属性组成的对象）的地址。而这个共用属性就是原型。原型出现的目的就是 为了减少不必要的内存消耗。

1.每个函数都有一个prototype属性，他默认指向一个object空对象（即成为：原型对象）
2.原型对象中有一个属性constructor，他指向函数对象

2.给原型对象添加属性（一般都是方法）
1.作用：函数的所有实例对象自动拥有原型中的属性（方法）
19.显式原型和隐式原型
1.每个函数function都有一个prototype，即显式原型（属性）
2.每个实例对象都一个__proto__，可称为隐式原型（属性）
3.实例对象的隐式原型的值为其对应构造函数的显示原型的值
4.图片
 

5.总结：
1.函数的prototype属性：在定义函数的时候自动添加，默认值是一个空的object对象
2.实例对象的__proto__属性：创建对象时自动添加的，默认值为构造函数的prototype属性值
3.程序员能直接操作显式原型，但不能直接操作隐式原型（ES6之前）

20.原型链
1.访问一个对象的属性时，先在自身的属性中查找，找到返回
2.如果没有，再沿着__proto__这条链向上查找，找到返回
3.如果最终没找到，返回undefined
补充：
1.函数的显式原型指向的对象是一个空的Object实例对象（但Object不满足）
console.log(Fn.prototype instanceof Object) //true
console.log(Object.prototype instanceof Object) //false
console.log(Function.prototype instanceof Object) //true

2.所有函数都是Function的实例（包含Function）
console.log(Function.__proto__===Function.prototype) // true

3.Object的原型对象是原型链的尽头
console.log(Object.prototype.__proto__)//null

  // 问题1
  function A() {}
  A.prototype.n = 1
  var b = new A()
  A.prototype = {
    n: 2,
    m: 3
  }
  var c = new A()
  console.log(b.n,b.m,c.n,c.m); // 1 undefined 2 3
  
  // 问题2
  function F(){}
  Object.prototype.a=function(){
    console.log('a()')
  }
  Function.prototype.b=function(){
    console.log('b()');
  }
  var f= new F()
  f.a() // a
  f.b() // Uncaught TypeError: f.b is not a function
  F.a() // a
  F.b() // b

21.什么是闭包
1.函数嵌套函数
2.内部函数访问外部函数变量
3.闭包只会在外部函数被调用的时候产生，也就是外部函数调用一次就产生一个闭包
22.闭包的优点和缺点，缺点的解决方式
优点：
1.可以防止变量全局污染
2.想让变量长期贮存在内存当中
缺点：
1.变量长期贮存在内存当中
2.容易造成内存泄漏
解决：
1.能不用就不用
2.及时释放
23.闭包的一些题目
1.闭包题目一
for (var i = 1; i <= 5; i++) { 
setTimeout(function timer(){
 console.log(i)
 	}, i * 1000)
 }
首先因为 setTimeout 是个异步函数，所以会先把循环全部执行完毕，这时候 i 就是 6 了，所以会输出一堆 6

解决办法有两种
第一种：闭包的方式
for (var i = 1; i <= 5; i++) { 
;(function(j) {
 setTimeout(function timer() {
 	console.log(j)
 }, j * 1000) 
})(i) }

第二种：let
for (let i = 1; i <= 5; i++) { 
setTimeout(function timer(){
 console.log(i)
 	}, i * 1000)
 }
2.闭包题目二this指向问题
var name = "window"
var obj = { 
name: "object", 
getName: function () { 
return function () { 
return this.name
 }
}
 } 
console.log(obj.getName()()) // window

var name = "window"
var obj = { 
name: "object", 
getName: function () { 
return function () { 
var that = this
return this.name
 }
 }
 } 
console.log(obj.getName()()) // object

3.闭包题目三
function fun(n,o) {
console.log(o);
return {
fun:function(m) {
return fun(m,n);
}
};
}
var a = fun(0);    //undefined
a.fun(1);           //0 
a.fun(2);			 //0 
a.fun(3); 		     //0 
var b = fun(0).fun(1).fun(2).fun(3); //undefined 0 1 2
var c = fun(0).fun(1); 
c.fun(2); 
c.fun(3); //undefined 0 1 1

24.什么是执行上下文？概念、执行环境、特点、创建阶段？
概念：
当js代码运行的时候，会产生一个对应的运行环境，这个环境中会把变量先提取出来（变量提升）然后从上到下执行，这就叫做执行上下文。

有三种执行环境：
1.全局环境：代码首先进入的环境
2.函数环境：函数被调用的时候执行的环境
3.eval函数

执行上下文的特点：
1.单线程，在主进程上运行
2.同步执行，从上往下按顺序执行
3.全局上下文中只有一个，关闭浏览器被栈弹出
4.函数执行上下文没有数目限制
5.函数每调用一次，都会产生一个执行上下文的环境

执行上下文的阶段分为三个：
1.创建阶段：
1.1生成变量对象
1.2建立作用域链
1.3确定this指向
2.执行阶段
2.1变量赋值
2.2函数引用
2.3执行其他代码
3.销毁阶段
执行完毕出栈，等待被回收销毁
25.什么是执行上下文栈？
全局代码执行前，JS引擎就会创建一个来存储一个栈来管理所有的执行上下文对象
在全局执行上下文（window）确定后，将其添加到栈中（压栈）
在函数执行上下文创建后，将其添加到到栈中（压栈）
在当函数执行完后，将栈顶的对象移除（出栈）
当所有的代码执行完后，栈中只剩下window




26.执行上下文具体过程？
1.全局执行上下文
在执行全局代码之前将window确定为全局执行上下文
对全局数据进行预处理
var定义的全局变量==>undefined，添加为window的属性
function声明的全局函数==>赋值（fun），添加为window的方法
this==>赋值（window）
开始执行全局代码

2.函数执行上下文  
在调用函数，准备执行函数体之前，创建对应的函数执行上下文对象（虚拟的，存在于栈中）
对局部数据进行预处理
形参变量==>赋值（实参）==>添加为执行上下文的属性
arguments==>赋值（实参列表），添加为执行上下文中的属性
var定义的局部变量==>undefined，添加为执行上下文中的属性
function声明函数==>赋值（fun），添加为执行上下文的方法
this==>赋值（调用函数的对象）
开始执行函数体代码
27.作用域和全局上下文的区别？
区别1：
全局作用域之外，每个函数都会创建自己的作用域，作用域在函数自定义的时候就已经确定了，而不是在函数调用时
全局执行上下文环境是在全局作用域之后，ks代码马上执行之前的创建
函数执行上下文是在调用函数时，函数体代码执行之前创建
区别2：
作用域是静态的，只要函数定义好了就一直存在，且不会在变化
执行上下文是动态的，调用函数的时候创建，函数调用结束就是被自动释放
区别3：
上下文环境（对象）是从属于所在的作用域
全局上下文环境==>全局作用域
函数上下文环境==>对应的函数使用作用域
28.作用域链
多个上下级关系作用域行成的链，他的方向是从内到外的
查找变量就是沿着作用域链来查找的



29.线程与进程
进程：
程序的一次执行，他占有一片独有的内存空间
可以通过windows任务管理器查看
线程：
是进程内的一个独立执行单元
是程序执行的一个完整流程
是cpu的最小的调度单元
关系：
一个进程至少有一个线程（主）
程序是在某个进程中的某个线程执行的
30.浏览器的内核模块组成
主线程：
js引擎模块：负责js程序的编译与运行
html，css文档解析模块：负责页面的文本解析
DOM/CSS模块：负责dom/css在内存中的相关处理
布局和渲染模块：负责页面的布局和效果的绘制（内存中的对象）
分线程：
定时器模块：负责定时器的管理
DOM事件模块：负责事件的管理
网络请求模块：负责Ajax请求
31.JS引擎执行的基本流程
先执行初始化代码：
设置定时器
绑定事件监听
发送ajax请求
后面在某个时刻才会执行回调函数
32.浏览器渲染的主要流程是什么？
解析HTML生成DOM树。
解析CSS生成CSSOM规则树。
将DOM树与CSSOM规则树合并在一起生成渲染树。
遍历渲染树开始布局，计算每个节点的位置大小信息。
将渲染树每个节点绘制到屏幕。


33.从输入url地址到页面响应发生了什么？
1.浏览器的地址栏输入URL并按下回车。
2.浏览器查找当前URL的DNS缓存记录。
3.DNS解析URL对应的IP。
4.根据IP建立TCP连接（三次握手）。
5.HTTP发起请求。
6.服务器处理请求，浏览器接收HTTP响应。
7.渲染页面，构建DOM树。
8.关闭TCP连接（四次挥手）。
34.三次握手四次挥手
1.第一次握手:
客户端发送syn包（syn=x）到服务器，并进入SYN_SEND状态，等待服务器确认。
2.第二次握手：
服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN_RECV状态。
3.第三次握手：
客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK（ack=y+1），此包发送完毕，客户端和服务器进入ESTABLISHED状态，三次握手。

注意：以上动作发送的包中没有任何数据，等三次握手完成后客户端与服务器才正式开始传送数据（握手是为了证明客户端和服务端都是正常的）

1.第一次挥手
客户端主动关闭方发送一个FIN，用来关闭客户端到服务器端的数据传送，也就是客户端告诉服务器端：我已经不会再给你发数据了， (当然，在 fin 包之前发送出去的数据，如果没有收到对应的 ack 确认报文，客户端依然会重发这些数据)，但是，此时客户端还可以接受数据。
2.第二次挥手
服务端收到FIN包后，发送一个ACK给客户端，确认序号为收到序号+1（与 SYN 相同，一个 FIN 占用一个序号）。
3.第三次挥手
服务器端发送一个FIN，用来关闭服务器端到客户端的数据传送，也就是告诉客户端，我的数据也发送完了，不会再给你发送数据了！！！
4.第四次挥手
客户端收到 FIN 后，发送一个 ACK 给服务端，确认序号为收到序号 + 1，至此，完成四次挥手。
35.为什么建立是三次握手，结束是四次挥手
建立时ACK和SYN放在一个报文里发送，结束时ACK和FIN一般都会分开发送。

36.var、let、const的区别
1.let 和const 定义的的变量会常量是具有块级作用域的。
2.var 定义的变量没有块级作用域的概念,但是会有变量提升,即 可在变量声明之前使用变量,let 和const 则不行。
3.被const 和let 声明的常量或变量不能再被重复声明(在同一个作用域内),var 可以重复声明变量,以最后定义的变量覆盖之前的原则定义。
4.const 定义常量,定义的时候就要赋初值,否则报错。let,var初始化时可以不赋初值。
5.const 定义的基本数据类型的常量不能被修改值,定义引用数据类型的常量引用数据的内部属性值是可以修改值的。
37.什么是变量提升？
代码初始化的时候会把var定义的变量优先添加为window属性并且赋值为undefined。
38.箭头函数和普通函数的区别？
·  箭头函数在语法上比普通函数更简洁
·  箭头函数没有 prototype(原型),所以箭头函数本身没有this
·  箭头函数的 this 指向在函数定义时就继承自外层第一个普通函数的this,所以箭头函数的this指向在定义的时候就已经确定,且之后永远不会改变。
·  使用 call,apply,bind 都不能改变箭头函数中的this指向
·  因为箭头函数没有子集的this且不会改变,所以箭头函数不能用定义构造函数,否则使用new 关键字会报错
·  箭头函数内部没有arguments ,而是rest 参数(...)代替arguments对象来访问箭头函数的参数列表
·  箭头函数不能用作 Generator 函数,不能使用 yield 关键字

39.说说你对promise的理解？
Promise,可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。Promise 的出现解决了 之前的回调地狱问题,并且Promise 实现了链式调用，也就是说每次调用 then 之后返回的都是一个 Promise ， 并且是一个全新的Promise 。
Promise的缺点:
首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。
其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。
第三，当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。

40.Generator函数，也叫*号函数
Generator 最大的特点就是可以控制函数的执行，我们可以通过 Generator 函数解决回调地狱的问题。
function *foo(x) {
let y = 2 * (yield (x + 1))
let z = yield (y / 3) 
return (x + y + z)
 }
 let it = foo(5) 
console.log(it.next()) // => {value: 6, done: false}
console.log(it.next(12)) // => {value: 8, done: false} 
console.log(it.next(13)) // => {value: 42, done: true} 

你也许会疑惑为什么会产生与你预想不同的值，接下来就让我为你逐行代码分析原因
首先 Generator 函数调用和普通函数不同，它会返回一个迭代器

当执行第一次 
next 时，传参会被忽略，并且函数暂停在 yield (x + 1) 处，所以返回 5 + 1 = 6
当执行第二次 
next 时，传入的参数等于上一个 yield 的返回值，如果你不传参，yield 永远返回 undefined。此时 let y = 2 * 12，所以第二个 yield 等于 2 * 12 / 3 = 8
当执行第三次 
next 时，传入的参数会传递给 z，所以 z = 13, x = 5, y = 24，相加等于 42

可以把之前的回调地狱例子改写为如下代码：
function *fetch() { 
yield ajax(url, () => {}) 
yield ajax(url1, () => {}) 
yield ajax(url2, () => {}) 
} 
let it = fetch() 
let result1 = it.next() 
let result2 = it.next() 
let result3 = it.next()
40.async和await的特点，它们的优点和缺点是什么？await的原理是什么？
1.一个函数如果加上 async ，那么该函数就会返回一个 Promise
2.async 和 await 可以说是异步终极解决方案了，相比直接使用 Promise 来说，优势在于处理 then 的调用链，能够更清晰准确的写出代码，毕竟写一大堆 then 也很恶心，并且也能优雅地解决回调地狱问题。
3.当然也存在一些缺点，因为 await 将异步代码改造成了同步代码，如果多个异步代码没有依赖性却使用了 await 会导致性能上的降低。

41.map , forEach , filter , reduce 各自有什么作用？
Map
不会改变原数组，会生成一个新的数组。
可以接收三个参数，分别是：每一项元素 ，索引 ，原数组。

ForEach
和map的语法一致，map可以做到的forEach一样可以做到。
区别
forEach不能return，返回值是undefined，不可以链式调用。
map返回一个新的数组，原数组不会改变

Filter
生成一个新的数组，不会改变原数组。
接收参数和map一样也是 每一项元素，索引，原数组

Reduce
reduce 可以将数组中的元素通过回调函数最终转换为一个值。
它接受两个参数，分别是回调函数和初始值
const arr = [1, 2, 3] 
const sum = arr.reduce((acc, current) => acc + current, 0) console.log(sum)
•  回调函数接受四个参数，分别为累计值、当前元素、当前索引、原数组
const arr = [1, 2, 3]
const mapArray = arr.map(value => value * 2) 
const reduceArray = arr.reduce((acc, current) => {
 acc.push(current * 2) 
return acc 
}, []) 
console.log(mapArray, reduceArray) // [2, 4, 6]

•  回调函数接受四个参数，分别为累计值、当前元素、当前索引、原数组
array.reduce(function(total, currentValue, currentIndex, arr), initialValue)
initialValue：传递给函数的初始值；
让数组中的前项和后项做某种计算，并累计最终值。
var newArr = [15.5, 2.3, 1.1, 4.7].reduce(function(total,num){
	return total + Math.round(num);//对数组元素进行四舍五入并计算总和
}, 0);
console.log(newArr);//24

42.你还使用过哪些ES6语法？
1.字符串模板
2.解构赋值
3.class
4.map , forEach , filter , reduce 
5.箭头函数
6.propx
7.Array.from:为数组转换成数组。(数组方法)
let fakeArr = { 0: 'a', 1: 'b', 2: 'c', length: 3 }; 
let arr = Array.from(fakeArr); 
console.log(arr); // ['a', 'b', 'c']

8.find:找到返回元素，找不到返回undefined。(数组方法)
9.findIndex:找到返回下标，找不到返回-1。(数组方法)
10.includes:判断是否包含某个值，包含返回true,不包含返回false。(数组方法)
11.set:数组去重[...new Set([2,3,2,4,5,6,3])]
12.startWith()：返回布尔值，表示参数字符串是否在原字符串的头部。
13.endWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。
 

43.什么是Symbol？
1.是ES6引入的一种新的数据类型，用来解决对象属性命名冲突。
2.symbol表示独一无二的值,它是原始数据类型，不能用new

44.为甚要使用模块化？有哪些方式可以实现模块化？它们各有什么特点？
原因：
1.解决命名冲突
2.提高复用性
3.提高代码可维护性



45.有哪些方式可以实现模块化？它们各有什么特点？
1.立即执行函数（匿名函数自调用）
(function(globalVariable){
globalVariable.test = function() {} 
// ... 声明各种变量、函数都不会污染全局作用域 
})(globalVariable)

2.AMD（异步执行）和CMD（同步执行）
AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块 
define(['./a', './b'], function(a, b) { 
// 依赖必须一开始就写好 
a.doSomething() 
... 
b.doSomething() 
...
 })
CMD推崇依赖就近，用到某个模块的时候再去require 
define(function(require, exports, module) { 
var a = require('./a') 
a.	doSomething() 
var b = require('./b') 
b.	doSomething() .
.. 
})

3.CommonJS（同步执行）
1.使用model.exports把需要的方法或者变量暴露出去。
2.使用require引入文件即可使用
commonJS 规范 千言万语不如一行代码：
//example.js 
var n = 1; 
function sayHello( name ){ 
	var name = name || "Tom"; 
	return "Hello~"+name 
} 
function addFn(val){ 
	var val = val.x+val.y; 
	return val 
} 
module.exports ={ n:n, sayHello:sayHello, addFn:addFn }



使用requier()引入使用
//main.js 
var example = require('./example.js'); 
var addNum = { "x":10, "y":5 } 
console.log( example )//查看example输出的对外模块接口； console.log( example.n )//1; console.log( example.sayHello("Jack") )// "Hello~ Jack"; console.log( example.addFn(addNum) ) //15;

4.ES Model（同步执行）
export
输出方式①
export var a=1;//输出简单变量
export function fn(){ // } //方法 
export class c{ //.... }  //类
输出方式②
var a=1; var b=2;     export{a,b};
function fn(){ // }   export{fn};
class c{ // }          export{c};

var a=1; export{a as b}       可以给输出的内容重命名，使用as来实现。
import {a as b} from '...js' 可以给输出的内容重命名，使用as来实现。

export default
输出方式①
var a=1; export default a;
export default function(){ //} //使用这个语法，输出非匿名函数也和上面一样。
输出方式①
var a=1; var b=2; expoprt default{a,b}
//正确写法 
export var a=1; 
var a=1; 
export default a; 
//错误写法 
export default var a=1;

// 引入模块 API 
import XXX from './a.js' 
import { XXX } from './a.js'





46.ES Model和commonJS的区别？
1.CommonJS支持动态导入，也就是require(${path}/xx.js)。
2..CommonJS是同步导入，ES Model是异步导入。
3.ES Model最终会被编译成 require/epoxrts来执行。
47.为什么0.1+0.2!=0.3？怎么解决？
1.因为js采用的是IEEE 754双精度版本（64位）
2.计算的时候会变成2进制进行计算
为什么console.log打印0.1+0.2=0.3是对的呢？
因为在打印的时候会把二进制转换为十进制，又把十进制转换为字符串。
打印出来其实是一个近似值console.log(0.100000000000000002) // 0.1

解决方式：
parseFloat((0.1 + 0.2).toFixed(10)) === 0.3 // true
47.什么是事件？什么是事件流？
1.事件：事件是JS跳动的心脏，可以是点击事件，也可以是鼠标经过某个地方触发某个事件或者是窗口改变触发事件等等。

2.事件流：事件流是从页面接收事件的顺序，微软和网景的事件流概念是相反的。微软的事件流是事件冒泡流，网景的事件流是事件捕获流。
捕获阶段=》目标阶段=》冒泡阶段
48.冒泡事件和事件捕获。
1.事件冒泡：从内向外触发
当父div与子div共同加入了onclick事件时，当触发了子div的onclick事件后，子div进行相应的js操作，但是父div的onclick事件同样会被触发。

<div id="div1"> <div id="div2"> <div id="div3"></div> </div> </div>
window.onload=function (){ 
var odiv1=document.getElementById("div1"); 
var odiv2=document.getElementById("div2")
var odiv3=document.getElementById("div3"); odiv1.addEventListener("click",function(){ alert("div1"); },false); odiv2.addEventListener("click",function(){ alert("div2"); },false); odiv3.addEventListener("click",function(){ alert("div3"); },false); }

点div2会输出div2然后输出div1
点div3会输出div3然后输出div2最后输出div1


2.事件捕获：从外向内触发
当父div与子div共同加入了onclick事件时，当触发了父div的onclick事件后，父div进行相应的js操作，但是子div的onclick事件同样会被触发。
点div2会输出div1然后输出div2
点div1会输出div1
点div3会输出div1然后输出div2最后输出div3

addEventListener的第二个属性是false就是事件冒泡，是true事件捕获。
49.什么是事件委托？
就是把事件委托给父级，利用事件冒泡，指定一个事件处理程序，就可以管理某一类型的所有事件。
 <ul>
   <li>1</li>
   <li>2</li>
 </ul>
var onUls = document.querySelector('ul')
onUls.onclick = function (e) {
      console.log(e.target);
      e.target.style.color = 'red'
    }
优点：
1.可以大量节省内存占用，减少事件注册。
2.可以实现动态绑定事件。
缺点：
1.可能会触发不想触发的事件（事件误判）。
2.事件触发事件会变长。
50.怎么阻止事件冒泡？
防止事件冒泡的一种方法是使用 event.stopPropagation()或 event.cancelBubble （低于 IE 9）。
 var odiv1 = document.getElementById("div1");
   var odiv2 = document.getElementById("div2");

   odiv1.addEventListener('click',function(e){
     e.stopPropagation()
     console.log('odiv1');
   },false)
   odiv2.addEventListener('click',function(e){
     e.stopPropagation()
     console.log('odiv2');
   },false)

51.回流和重绘？
回流：
当 Render Tree 中部分或全部, 因元素的尺寸、布局、隐藏等改变而需要重新构建，浏览器重新渲染的过程称为 回流。

会导致回流的操作：
1.页面首次渲染。
2.浏览器窗口大小发生改变。
3.元素尺寸或者位置发生改变。
4.元素内容变化(文字数量或者图片大小发生改变)。
5.元素字体大小的改变。
6.添加或者删除可见的 DOM 元素。激活 CSS 伪类 (eg: :hover)。
7.查询某些属性或调用某些方法。

会导致回流的方法：
•  clientWidth、clientHeight、clientTop、clientLeft
•  offsetWidth、offsetHeight、offsetTop、offsetLeft
•  scrollWidth、scrollHeight、scrollTop、scrollLeft
重绘：
当页面中元素样式的改变并不影响b布局时（eg：color、background-color等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。

一句话： 回流必将引起重绘，重绘不一定会引起回流。
52.优化重绘和回流？
减少对 render tree 的操作 【合并多次DOM和样式的修改】
减少对一些style信息的请求。
要修改的样式集中到一个 class 内统一修改。
避免使用 table 布局。
尽可能在DOM树的最末端改变class，尽可能在DOM树的里面改变class。
使用display:none，只引发两次回流和重绘。
避免频繁操作样式。
不要经常访问会引起浏览器缓存队列的属性。

•  clientWidth、clientHeight、clientTop、clientLeft
•  offsetWidth、offsetHeight、offsetTop、offsetLeft
•  scrollWidth、scrollHeight、scrollTop、scrollLeft




第四部分Vue
1.什么是mvvm？
mvvm 是一种设计思想。Model 层代表数据模型，也可以在 Model 中定义数据修改和操作的业务逻辑；View 代表 UI 组件，它负责将数据模型转化成 UI 展现出来，ViewModel 是一个同步 View 和 Model 的对象。
在 MVVM 架构下，View 和 Model 之间并没有直接的联系，而是通过 ViewModel 进行交互，Model 和 ViewModel 之间的交互是双向的， 因此 View 数据的变化会同步到 Model 中，而 Model 数据的变化也会立即反应到 View 上。
ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而 View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作 DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。
2.mvvm和mvc的区别？
mvc 和 mvvm 其实区别并不大。都是一种设计思想。主要就是 mvc 中 Controller 演变成 mvvm 中的 viewModel。mvvm 主要解决了 mvc 中大量的 DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。和当 Model 频繁发生变化，开发者需要主动更新到 View 。

View 传送指令到 Controller
Controller 完成业务逻辑后，要求 Model 改变状态
Model 将新的数据发送到 View，用户得到反馈
 

	
1.各部分之间的通信，都是双向的。
2.View 与 Model 不发生联系，都通过 ViewModel传递。
3.View层处理交互，model层进行数据处理，ViewModel进行数据逻辑处理。
 
3.vue双向绑定原理？
vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty()来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。
第一步：需要 observe 的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter 和 getter 这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化
第二步：compile 解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图
第三步：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁，主要做的事情是:
在自身实例化时往属性订阅器(dep)里面添加自己
自身必须有一个 update()方法
待属性变动 dep.notice()通知时，能调用自身的 update() 方法，并触发 Compile 中绑定的回调，则功成身退。
第四步：MVVM 作为数据绑定的入口，整合 Observer、Compile 和 Watcher 三者，通过 Observer 来监听自己的 model 数据变化，通过 Compile 来解析编译模板指令，最终利用 Watcher 搭起 Observer 和 Compile 之间的通信桥梁，达到数据变化 -> 视图更新；视图交互变化(input) -> 数据 model 变更的双向绑定效果。

4.vue的优点是什么？
1.低耦合。
2.可重性。
3.独立开发。
4.可测试。
5.v-if和v-show的区别？
1.都是条件渲染。
2.v-show是css切换，html元素还在。
3.v-if是dispay的block和none来回切换。
6.路由的跳转方式？
1.router-link标签会渲染为标签，咋填template中的跳转都是这种。
2.另一种是编辑是导航，也就是通过js跳转比如router.push('/home')。
7.vue的生命周期？
1.beforecreated：在实例初始化之后，el 和 data 并未初始化（这个时期，this变量还不能使用，在data下的数据，和methods下的方法，watcher中的事件都不能获得到；）
2.created:完成了 data 数据的初始化，el没有（这个时候可以操作vue实例中的数据和各种方法，但是还不能对"dom"节点进行操作；）
3.beforeMount：完成了 el 和 data 初始化 //这里的el是虚拟的dom；
4.mounted ：完成挂载，在这发起后端请求，拿回数据，配合路由钩子做一些事情（挂载完毕，这时dom节点被渲染到文档内，一些需要dom的操作在此时才能正常进行）
5.beforeUpdate：是指view层数据变化前，不是data中的数据改变前触发；
6.update：是指view层的数据变化之后，
7.beforeDestory： 你确认删除XX吗？
8.destoryed ：当前组件已被删除，清空相关内容

A、什么是vue生命周期？
Vue 实例从创建到销毁的过程，就是生命周期。也就是从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。





8.computed和watch的区别？
1.computed
computed是计算属性，也就是计算值，它更多用于计算值的场景。
computed具有缓存性，computed的值在getter执行后是会缓存的，只有在它依赖的属性值改变之后，下一次获取computed的值时重新调用对应的getter来计算。
computed适用于计算比较消耗性能的计算场景。



2.watch
watch更多的是[观察]的作用，类似于某些数据的监听回调，用于观察props $emit或者本组件的值，当数据变化时来执行回调进行后续操作。
无缓存性，页面重新渲染时值不变化也会执行。

3.当我们要进行数值计算，而且依赖于其他数据，那么把这个数据设计为computed
如果你需要在某个数据变化时做一些事情，使用watch来观察这个数据变化。
9.vue里面scoped的作用？
样式私有化，只作用于当前模块下。
10.vue的两个核心是什么？
数据驱动和组件驱动。
11.vue常用的修饰符？
1.一般修饰符: v-model .number  .trim

2.事件修饰符:
<a v-on:click.stop="doThis"></a><!-- 阻止单击事件继续传播 -->
<form v-on:submit.prevent="onSubmit"></form> <!-- 提交事件不再重载页面 -->
<a v-on:click.stop.prevent="doThat"></a> <!-- 修饰符可以串联 -->
<form v-on:submit.prevent></form>   <!-- 只有修饰符 -->
<div v-on:click.capture="doThis">...</div>   <!-- 添加事件监听器时使用事件捕获模式 --> <!-- 即元素自身触发的事件先在此处处理，然后才交由内部元素进行处理 -->
<div v-on:click.self="doThat">...</div>  <!-- 只当在 event.target 是当前元素自身时触发处理函数 --> <!-- 即事件不是从内部元素触发的 -->
<a v-on:click.once="doThis"></a> <!-- 点击事件将只会触发一次 -->

3.按件修饰符:
.enter .tab .delete .esc .space .up .down .left .right .ctrl .alt .shift .meta
<input v-on:keyup.enter="submit"> 或者 <input @keyup.enter="submit">

4.按件修饰符:
.ctrl .alt .shift .meta
<input @keyup.alt.67="clear"> 或者 <div @click.ctrl="doSomething">Do something</div><!-- Ctrl + Click -->

12.vue里面如何使用event对象？
<button @click="Event($event)">事件对象</button>
13.vue组件里的data为什么必须是函数？
原因：因为组件是需要被复用的，所以必须是一个函数，如果是一个对象，作用域没有分开，子组件 的data属性值会相互影响。是一个函数的话那么每个实例可以维护一份被返回对象的独立的拷贝，组 件之间的 data 属性值不会互相影响。
14.为什么new Vue里data可以是一个对象？
原因：因为JS里的对象是引用关系，而且new Vue是不会被复用的，所以不存在引用对象的问题。
15.vue单页面的优点和缺点？
缺点
不支持低版本的浏览器，最低只支持到IE9；
不利于SEO的优化（如果要支持SEO，建议通过服务端来进行渲染组件）；
第一次加载首页耗时相对长一些；
不可以使用浏览器的导航按钮需要自行实现前进、后退。

优点
无刷新体验,提升了用户体验；
前端开发不再以页面为单位，更多地采用组件化的思想，代码结构和组织方式更加规范化，便于修改和调整；
API 共享，同一套后端程序代码不用修改就可以用于Web界面、手机、平板等多种客户端
用户体验好、快，内容的改变不需要重新加载整个页面。
16.vue导航钩子？
全局的:前置守卫、后置钩子（beforeEach，afterEach）beforeResolve
单个路由独享的:beforeEnter
组件级的: beforeRouteEnter（不能获取组件实例 this）、beforeRouteUpdate、beforeRouteLeave
这是因为在执行路由钩子函数beforRouteEnter时候，组件还没有被创建出来；
先执行beforRouteEnter，再执行组件周期钩子函数beforeCreate，可以通过 next 获取组件的实例对象，如：next( (vm)=>{} )，参数vm就是组件的实例化对象。
17.vue-router导航解析流程？
1.导航被触发。
2.在失活的组件里调用beforeRouteLeave守卫。
3.调用全局beforeEach守卫。
4.在复用组件里调用beforeRouteUpdate守卫。
5.调用路由配置里的beforeEnter守卫。
6.解析异步路由组件。
7.在被激活的组件里调用beforeRouteEnter守卫。
8.调用全局beforeResolve守卫。
9.导航被确认。
10..调用全局的afterEach钩子。
11.DOM更新。
12.用创建好的实例调用beforeRouteEnter守卫中传给next的回调函数。
18.vueX有哪几种属性？
有 5 种，分别是 state、getter、mutation、action、module
19.vueX getter的特性是什么？
getter 可以对 state 进行计算操作，它就是 store 的计算属性。
虽然在组件内也可以做计算属性，但是 getters 可以在多给件之间复用。
如果一个状态只在一个组件内使用，是可以不用 getters。
20.vueX mutation的特性是什么？
action 类似于 muation, 不同在于：action 提交的是 mutation,而不是直接变更状态。
action 可以包含任意异步操作。
如果被其他地方复用，请将请求放入 action 里，方便复用，并包装成 promise 返回。
21.Vuex 如何区分 state 是外部直接修改，还是通过 mutation 方法修改的？
Vuex 中修改 state 的唯一渠道就是执行 commit('xx', payload) 方法，其底层通过执行 this._withCommit(fn) 设置_committing 标志变量为 true，然后才能修改 state，修改完毕还需要还原_committing 变量。外部修改虽然能够直接修改 state，但是并没有修改_committing 标志位，所以只要 watch 一下 state，state change 时判断是否_committing 值为 true，即可判断修改的合法性。




22.vuex 原理
vuex 仅仅是作为 vue 的一个插件而存在，不像 Redux,MobX 等库可以应用于所有框架，vuex 只能使用在 vue 上，很大的程度是因为其高度依赖于 vue 的 computed 依赖检测系统以及其插件系统，
vuex 整体思想诞生于 flux,可其的实现方式完完全全的使用了 vue 自身的响应式设计，依赖监听、依赖收集都属于 vue 对对象 Property set get 方法的代理劫持。最后一句话结束 vuex 工作原理，vuex 中的 store 本质就是没有 template 的隐藏着的 vue 组件；
23.用过keep-alive吗，说说对它的理解？
keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，避免重新渲染 ，有以下特性：
1、一般结合路由和动态组件一起使用，用于缓存组件。
2、提供 include 和 exclude 属性，两者都支持字符串或正则表达式， include 表示只有名称匹 配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存 ，其中 exclude 的优先级比 include 高。
3、对应两个钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated， 当组件被移除时，触发钩子函数 deactivated。


